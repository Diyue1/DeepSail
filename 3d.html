<html>
<head>
    <meta charset="utf-8">
    <title>èˆªçº¿è¿½è¸ª</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        #home-button { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 1; 
            background-color: white; 
            border: 1px solid #ccc; 
            padding: 10px 15px; 
            border-radius: 5px; 
            cursor: pointer; 
            text-decoration: none; 
            color: black; 
        }
        #route-input {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #file-input {
            display: none;
        }
        #wave-file-input {
            display: none;
        }
        #file-label, #wave-file-label {
            display: inline-block;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
        }
        #start-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .route-info {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #loading-indicator {
            display: none;
            margin-left: 10px;
            color: #555;
        }
        #debug-info {
            position: absolute;
            top: 100px;
            right: 20px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            display: none;
        }
        #wave-data-section {
            margin-top: 10px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }
        #toggle-waves-button {
            margin-top: 5px;
            padding: 5px 10px;
            background-color: #1E90FF;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        /* æµ·æ´‹æ§åˆ¶æŒ‰é’®æ ·å¼ */
        #ocean-controls {
            margin-top: 10px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }
        #ocean-controls button {
            margin: 2px;
            padding: 5px 8px;
            background-color: #1E90FF;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #ocean-controls button:hover {
            background-color: #0066CC;
        }
        #ocean-controls button.active {
            background-color: #004080;
            font-weight: bold;
        }
        
        /* æµ·æ´‹æ•°æ®æ ‡è®°æ ·å¼ */
        .current-marker {
            width: 20px;
            height: 20px;
            background-color: rgba(0, 100, 255, 0.7);
            border-radius: 50%;
            border: 1px solid white;
        }
        .wind-marker {
            font-size: 18px;
            text-align: center;
        }
        .wave-marker {
            font-size: 20px;
            text-align: center;
        }
        .typhoon-marker {
            width: 24px;
            height: 24px;
            background-color: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            border: 2px solid white;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
    </style>
</head>
<body>
    <a href="index.html" id="home-button">é¦–é¡µ</a>
    
    <div id="route-input">
        <input type="text" id="start-point" placeholder="èµ·ç‚¹">
        <input type="text" id="end-point" placeholder="ç»ˆç‚¹">
        <button onclick="loadRoute()">ç¡®å®šèˆªçº¿</button>
        <span id="loading-indicator">åŠ è½½ä¸­...</span>

        <!-- æµ·æ´‹æ•°æ®æ§åˆ¶åŒº -->
        <div id="ocean-controls">
            <button id="ocean-currents-btn" onclick="toggleOceanCurrents()">æ´‹æµ</button>
            <button id="wind-direction-btn" onclick="toggleWindDirection()">é£å‘</button>
            <button id="wave-height-btn" onclick="toggleWaveHeight()">æµ·æµª</button>
            <button id="typhoon-info-btn" onclick="toggleTyphoonInfo()">å°é£</button>
        </div>
    </div>

    <button id="start-button" style="display:none;" onclick="startShipAnimation()">å¯åŠ¨èˆªè¡Œ</button>
    
    <div class="route-info" id="route-info" style="display:none;">
        <h3>èˆªçº¿ä¿¡æ¯</h3>
        <div id="route-details"></div>
    </div>

    <div id="debug-info"></div>

    <div id="map"></div>

    <script>
        // Mapboxé…ç½®
        mapboxgl.accessToken = 'pk.eyJ1IjoieXpmZGVmbTUiLCJhIjoiY202M2pvbXE1MWF0MjJ3b2xjdm91OWt0biJ9.5MW_rT9cyvGDt2qAt-yAgg';
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [0, 0],
            zoom: 2.5,
            pitch: 45,
            projection: 'globe'
        });

        // è°ƒè¯•æ¨¡å¼å¼€å…³
        const DEBUG_MODE = false;

        // å…¨å±€å˜é‡
        let routeCoordinates = [];
        let routeMetadata = {};
        let shipMarker = null;
        let routeSource = null;
        let animationFrame = null;
        let animationSpeed = 100; // æ¯«ç§’/ç‚¹
        let wayPointMarkers = []; // å­˜å‚¨èˆªç‚¹æ ‡è®°çš„æ•°ç»„
        let waveMarkers = []; // å­˜å‚¨é£æµªæ ‡è®°çš„æ•°ç»„
        let currentMarkers = []; // å­˜å‚¨æ´‹æµæ ‡è®°çš„æ•°ç»„
        let windMarkers = []; // å­˜å‚¨é£å‘æ ‡è®°çš„æ•°ç»„
        let typhoonMarkers = []; // å­˜å‚¨å°é£æ ‡è®°çš„æ•°ç»„
        
        // æµ·æ´‹æ•°æ®çŠ¶æ€
        let oceanData = {
            currentsVisible: false,
            windVisible: false,
            wavesVisible: false,
            typhoonVisible: false
        };

        // é¢„å®šä¹‰çš„èˆªçº¿æ˜ å°„è¡¨
        const ROUTE_MAPPINGS = {
            "å¹¿å·æ¸¯-æ—¥æœ¬ç¦å†ˆæ¸¯": "guangzhou-japan",
            "ä¸Šæµ·æ¸¯-æ™ºåˆ©ç“¦æ–¯ç§‘æ¸¯": "shanghai-southamerica",
            "çº½çº¦/æ–°æ³½è¥¿æ¸¯-æ‰˜ä¼¯è«é‡Œæ¸¯":"america-england"
        };

        // æµ·æ´‹æ•°æ® - å®é™…åº”ç”¨ä¸­å¯ä»¥ä»APIè·å–
        const OCEAN_DATA = {
            // æ´‹æµæ•°æ® [ç»åº¦, çº¬åº¦, æµé€Ÿ(èŠ‚), æ–¹å‘(åº¦), åç§°]
            currents: [
                [135.0, 32.0, 2.5, 45, "é»‘æ½®"],
                [140.0, 30.0, 1.8, 60, "åŒ—èµ¤é“æš–æµ"],
                [150.0, 25.0, 2.0, 70, "æ—¥æœ¬æš–æµ"],
                [130.0, 20.0, 1.5, 30, "å°æ¹¾æš–æµ"],
                [120.0, 15.0, 1.2, 20, "å—æµ·æš–æµ"],
                [160.0, 10.0, 0.8, 10, "èµ¤é“é€†æµ"]
            ],
            
            // é£å‘æ•°æ® [ç»åº¦, çº¬åº¦, é£å‘(åº¦), é£é€Ÿ(èŠ‚)]
            winds: [
                [130.0, 35.0, 90, 15],
                [135.0, 32.0, 95, 18],
                [140.0, 30.0, 100, 20],
                [145.0, 28.0, 105, 22],
                [125.0, 25.0, 85, 12],
                [150.0, 20.0, 110, 25]
            ],
            
            // æµªé«˜æ•°æ® [ç»åº¦, çº¬åº¦, æµªé«˜(ç±³), å‘¨æœŸ(ç§’)]
            waves: [
                [132.0, 34.0, 2.5, 8],
                [137.0, 31.0, 3.0, 9],
                [142.0, 28.0, 3.5, 10],
                [127.0, 25.0, 2.0, 7],
                [147.0, 22.0, 4.0, 11],
                [152.0, 19.0, 4.5, 12]
            ],
            
            // å°é£æ•°æ® [ç»åº¦, çº¬åº¦, åç§°, ç­‰çº§, é£é€Ÿ(èŠ‚), ç§»åŠ¨æ–¹å‘(åº¦), ç§»åŠ¨é€Ÿåº¦(èŠ‚)]
            typhoons: [
            ]
        };

        // è°ƒè¯•ä¿¡æ¯å‡½æ•°
        function debugLog(message) {
            if (DEBUG_MODE) {
                console.log(message);
                const debugDiv = document.getElementById('debug-info');
                debugDiv.style.display = 'block';
                debugDiv.innerHTML += `<p>${message}</p>`;
            }
        }

        // æ¸…é™¤è°ƒè¯•ä¿¡æ¯
        function clearDebugLog() {
            if (DEBUG_MODE) {
                document.getElementById('debug-info').innerHTML = '';
            }
        }

        // æ¸…é™¤æ‰€æœ‰èˆªç‚¹æ ‡è®°
        function clearWaypoints() {
            wayPointMarkers.forEach(marker => marker.remove());
            wayPointMarkers = [];
        }

        // æ¸…é™¤æ‰€æœ‰æ´‹æµæ ‡è®°
        function clearCurrentMarkers() {
            currentMarkers.forEach(marker => marker.remove());
            currentMarkers = [];
        }

        // æ¸…é™¤æ‰€æœ‰é£å‘æ ‡è®°
        function clearWindMarkers() {
            windMarkers.forEach(marker => marker.remove());
            windMarkers = [];
        }

        // æ¸…é™¤æ‰€æœ‰é£æµªæ ‡è®°
        function clearWaveMarkers() {
            waveMarkers.forEach(marker => marker.remove());
            waveMarkers = [];
        }

        // æ¸…é™¤æ‰€æœ‰å°é£æ ‡è®°
        function clearTyphoonMarkers() {
            typhoonMarkers.forEach(marker => marker.remove());
            typhoonMarkers = [];
        }

        // åˆ‡æ¢æ´‹æµæ˜¾ç¤º
        function toggleOceanCurrents() {
            oceanData.currentsVisible = !oceanData.currentsVisible;
            document.getElementById('ocean-currents-btn').classList.toggle('active');
            
            if (oceanData.currentsVisible) {
                addCurrentMarkers();
            } else {
                clearCurrentMarkers();
            }
        }

        // åˆ‡æ¢é£å‘æ˜¾ç¤º
        function toggleWindDirection() {
            oceanData.windVisible = !oceanData.windVisible;
            document.getElementById('wind-direction-btn').classList.toggle('active');
            
            if (oceanData.windVisible) {
                addWindMarkers();
            } else {
                clearWindMarkers();
            }
        }

        // åˆ‡æ¢æµªé«˜æ˜¾ç¤º
        function toggleWaveHeight() {
            oceanData.wavesVisible = !oceanData.wavesVisible;
            document.getElementById('wave-height-btn').classList.toggle('active');
            
            if (oceanData.wavesVisible) {
                addWaveMarkers();
            } else {
                clearWaveMarkers();
            }
        }

        // åˆ‡æ¢å°é£ä¿¡æ¯æ˜¾ç¤º
        function toggleTyphoonInfo() {
            oceanData.typhoonVisible = !oceanData.typhoonVisible;
            document.getElementById('typhoon-info-btn').classList.toggle('active');
            
            if (oceanData.typhoonVisible) {
                addTyphoonMarkers();
            } else {
                clearTyphoonMarkers();
            }
        }

        // æ·»åŠ æ´‹æµæ ‡è®°
        function addCurrentMarkers() {
            clearCurrentMarkers();
            
            OCEAN_DATA.currents.forEach(current => {
                const [lng, lat, speed, direction, name] = current;
                
                // åˆ›å»ºæ ‡è®°å…ƒç´ 
                const el = document.createElement('div');
                el.className = 'current-marker';
                
                // åˆ›å»ºç®­å¤´æŒ‡ç¤ºæ–¹å‘
                const arrow = document.createElement('div');
                arrow.style.width = '0';
                arrow.style.height = '0';
                arrow.style.borderLeft = '6px solid transparent';
                arrow.style.borderRight = '6px solid transparent';
                arrow.style.borderBottom = `12px solid rgba(0, 100, 255, 0.8)`;
                arrow.style.position = 'absolute';
                arrow.style.top = '-12px';
                arrow.style.left = '4px';
                arrow.style.transform = `rotate(${direction}deg)`;
                arrow.style.transformOrigin = 'center 12px';
                
                el.appendChild(arrow);
                
                // åˆ›å»ºæ ‡è®°
                const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center'
                })
                .setLngLat([lng, lat])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <h4>æ´‹æµä¿¡æ¯</h4>
                    <p><strong>åç§°:</strong> ${name}</p>
                    <p><strong>æµé€Ÿ:</strong> ${speed} èŠ‚</p>
                    <p><strong>æ–¹å‘:</strong> ${direction}Â°</p>
                `))
                .addTo(map);
                
                currentMarkers.push(marker);
            });
            
            debugLog(`æ·»åŠ äº†${currentMarkers.length}ä¸ªæ´‹æµæ ‡è®°`);
        }

        // æ·»åŠ é£å‘æ ‡è®°
        function addWindMarkers() {
            clearWindMarkers();
            
            OCEAN_DATA.winds.forEach(wind => {
                const [lng, lat, direction, speed] = wind;
                
                // åˆ›å»ºæ ‡è®°å…ƒç´ 
                const el = document.createElement('div');
                el.className = 'wind-marker';
                el.innerHTML = 'ğŸŒ¬ï¸';
                el.style.transform = `rotate(${direction}deg)`;
                
                // åˆ›å»ºæ ‡è®°
                const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center'
                })
                .setLngLat([lng, lat])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <h4>é£å‘ä¿¡æ¯</h4>
                    <p><strong>é£å‘:</strong> ${direction}Â°</p>
                    <p><strong>é£é€Ÿ:</strong> ${speed} èŠ‚</p>
                `))
                .addTo(map);
                
                windMarkers.push(marker);
            });
            
            debugLog(`æ·»åŠ äº†${windMarkers.length}ä¸ªé£å‘æ ‡è®°`);
        }

        // æ·»åŠ æµªé«˜æ ‡è®°
        function addWaveMarkers() {
            clearWaveMarkers();
            
            OCEAN_DATA.waves.forEach(wave => {
                const [lng, lat, height, period] = wave;
                
                // åˆ›å»ºæ ‡è®°å…ƒç´ 
                const el = document.createElement('div');
                el.className = 'wave-marker';
                
                // æ ¹æ®æµªé«˜é€‰æ‹©ä¸åŒçš„emoji
                let waveEmoji;
                if (height < 1) waveEmoji = 'ğŸŒŠ';
                else if (height < 2) waveEmoji = 'ğŸŒŠ';
                else if (height < 3) waveEmoji = 'ğŸŒŠ';
                else if (height < 4) waveEmoji = 'ğŸŒŠ';
                else waveEmoji = 'ğŸŒŠ';
                
                el.innerHTML = waveEmoji;
                el.style.fontSize = `${Math.min(30, 20 + height * 5)}px`;
                
                // åˆ›å»ºæ ‡è®°
                const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center'
                })
                .setLngLat([lng, lat])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <h4>æµ·æµªä¿¡æ¯</h4>
                    <p><strong>æµªé«˜:</strong> ${height} ç±³</p>
                    <p><strong>å‘¨æœŸ:</strong> ${period} ç§’</p>
                `))
                .addTo(map);
                
                waveMarkers.push(marker);
            });
            
            debugLog(`æ·»åŠ äº†${waveMarkers.length}ä¸ªæµªé«˜æ ‡è®°`);
        }

        // æ·»åŠ å°é£æ ‡è®°
        function addTyphoonMarkers() {
            clearTyphoonMarkers();
            
            OCEAN_DATA.typhoons.forEach(typhoon => {
                const [lng, lat, name, level, speed, direction, moveSpeed] = typhoon;
                
                // åˆ›å»ºæ ‡è®°å…ƒç´ 
                const el = document.createElement('div');
                el.className = 'typhoon-marker';
                
                // åˆ›å»ºæ ‡è®°
                const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center'
                })
                .setLngLat([lng, lat])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <h4>å°é£ä¿¡æ¯</h4>
                    <p><strong>åç§°:</strong> ${name}</p>
                    <p><strong>ç­‰çº§:</strong> ${level}</p>
                    <p><strong>é£é€Ÿ:</strong> ${speed} èŠ‚</p>
                    <p><strong>ç§»åŠ¨æ–¹å‘:</strong> ${direction}Â°</p>
                    <p><strong>ç§»åŠ¨é€Ÿåº¦:</strong> ${moveSpeed} èŠ‚</p>
                    <p style="color:red;font-weight:bold;">è¯·æ³¨æ„é¿è®©!</p>
                `))
                .addTo(map);
                
                typhoonMarkers.push(marker);
            });
            
            debugLog(`æ·»åŠ äº†${typhoonMarkers.length}ä¸ªå°é£æ ‡è®°`);
        }

        function unwrapRouteCoordinates(coords) {
            if (coords.length < 2) return coords;

            const result = [coords[0]];
            let previousLng = coords[0][0];

            for (let i = 1; i < coords.length; i++) {
                let [lng, lat] = coords[i];

                // å¤„ç†ç»åº¦å·®å€¼è¶…è¿‡180åº¦çš„é—®é¢˜
                while (lng - previousLng > 180) lng -= 360;
                while (lng - previousLng < -180) lng += 360;

                result.push([lng, lat]);
                previousLng = lng;
            }

            return result;
        }

        // å¤„ç†JSONæ ¼å¼çš„èˆªçº¿æ•°æ®
        function processJsonRoute(data) {
            if (data.coordinates && Array.isArray(data.coordinates)) {
                routeCoordinates = unwrapRouteCoordinates(data.coordinates);

                // æå–å…ƒæ•°æ®
                routeMetadata = {
                    name: data.name || 'æœªå‘½åèˆªçº¿',
                    startPoint: data.startPoint || 'æœªæŒ‡å®š',
                    endPoint: data.endPoint || 'æœªæŒ‡å®š',
                    distance: data.distance || 'æœªè®¡ç®—',
                    estimatedTime: data.estimatedTime || 'æœªæŒ‡å®š',
                    description: data.description || ''
                };
                
                // æ›´æ–°ç•Œé¢
                clearWaypoints(); // æ¸…é™¤ä¹‹å‰çš„èˆªç‚¹æ ‡è®°
                updateRouteInfo();
                drawRoute();
                document.getElementById('start-button').style.display = 'block';
                debugLog("JSONèˆªçº¿æ•°æ®å¤„ç†æˆåŠŸ");
            } else {
                throw new Error('JSONæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œç¼ºå°‘åæ ‡æ•°ç»„');
            }
        }

        // å¤„ç†TXTæ ¼å¼çš„èˆªçº¿æ•°æ®
        function processTxtRoute(text) {
            const coordinates = text.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .map(line => {
                    const parts = line.split(',');
                    if (parts.length !== 2) {
                        console.warn(`å¿½ç•¥æ— æ•ˆè¡Œ: ${line}`);
                        return null;
                    }
                    const lng = parseFloat(parts[0].trim());
                    const lat = parseFloat(parts[1].trim());
                    if (isNaN(lng) || isNaN(lat)) {
                        console.warn(`å¿½ç•¥æ— æ•ˆåæ ‡: ${line}`);
                        return null;
                    }
                    return [lng, lat];
                })
                .filter(coord => coord !== null);

            routeCoordinates = unwrapRouteCoordinates(coordinates);
                
            if (routeCoordinates.length < 2) {
                throw new Error('æœ‰æ•ˆåæ ‡ç‚¹ä¸è¶³ï¼Œè‡³å°‘éœ€è¦2ä¸ªç‚¹');
            }

            // è®¾ç½®åŸºæœ¬å…ƒæ•°æ®
            const start = document.getElementById('start-point').value || 'æœªæŒ‡å®š';
            const end = document.getElementById('end-point').value || 'æœªæŒ‡å®š';
            
            routeMetadata = {
                name: `${start} è‡³ ${end}`,
                startPoint: start,
                endPoint: end,
                distance: 'æœªè®¡ç®—',
                estimatedTime: 'æœªæŒ‡å®š',
                description: 'ä»æ–‡æœ¬æ–‡ä»¶åŠ è½½çš„èˆªçº¿'
            };
            
            // æ›´æ–°ç•Œé¢
            clearWaypoints(); // æ¸…é™¤ä¹‹å‰çš„èˆªç‚¹æ ‡è®°
            updateRouteInfo();
            drawRoute();
            document.getElementById('start-button').style.display = 'block';
            debugLog("TXTèˆªçº¿æ•°æ®å¤„ç†æˆåŠŸ");
        }

        // æ›´æ–°èˆªçº¿ä¿¡æ¯é¢æ¿
        function updateRouteInfo() {
            const infoDiv = document.getElementById('route-info');
            const detailsDiv = document.getElementById('route-details');
            
            detailsDiv.innerHTML = `
                <p><strong>èˆªçº¿åç§°:</strong> ${routeMetadata.name}</p>
                <p><strong>èµ·ç‚¹:</strong> ${routeMetadata.startPoint}</p>
                <p><strong>ç»ˆç‚¹:</strong> ${routeMetadata.endPoint}</p>
                ${routeMetadata.description ? `<p><strong>æè¿°:</strong> ${routeMetadata.description}</p>` : ''}
                <p><strong>èˆªç‚¹æ•°é‡:</strong> ${routeCoordinates.length}</p>
            `;
            
            infoDiv.style.display = 'block';
        }

        // è·å–èˆªçº¿æ–‡ä»¶å
        function getRouteFileName(start, end) {
            // æ ‡å‡†åŒ–è¾“å…¥ (è½¬å°å†™ï¼Œç§»é™¤ç©ºæ ¼)
            const normalizedStart = start.toLowerCase().trim();
            const normalizedEnd = end.toLowerCase().trim();
            
            // å°è¯•ä¸åŒçš„ç»„åˆæ–¹å¼æŸ¥æ‰¾åŒ¹é…
            const combinations = [
                `${normalizedStart}-${normalizedEnd}`,  // ä¾‹å¦‚: "g-j"
                `${start}-${end}`,                     // ä¾‹å¦‚: "å¹¿å·-æ—¥æœ¬"
                `${normalizedStart}_${normalizedEnd}`   // ä¾‹å¦‚: "guangzhou_japan"
            ];
            
            // æ£€æŸ¥æ˜ å°„è¡¨ä¸­æ˜¯å¦å­˜åœ¨åŒ¹é…
            for (const combo of combinations) {
                debugLog(`å°è¯•åŒ¹é…ç»„åˆ: ${combo}`);
                if (ROUTE_MAPPINGS[combo]) {
                    return ROUTE_MAPPINGS[combo];
                }
            }
            
            // å¦‚æœæ²¡æœ‰åœ¨æ˜ å°„è¡¨ä¸­æ‰¾åˆ°ï¼Œåˆ™ä½¿ç”¨æ ‡å‡†å‘½åæ ¼å¼
            debugLog("æœªæ‰¾åˆ°é¢„å®šä¹‰æ˜ å°„ï¼Œä½¿ç”¨æ ‡å‡†æ ¼å¼");
            return `${normalizedStart}_${normalizedEnd}`;
        }

        // ä»æœåŠ¡å™¨åŠ è½½èˆªçº¿
        function loadRoute() {
            clearDebugLog();
            const startPoint = document.getElementById('start-point').value;
            const endPoint = document.getElementById('end-point').value;
            
            // æ·»åŠ è·¯å¾„éªŒè¯
            if (!startPoint || !endPoint) {
                alert('è¯·è¾“å…¥èµ·ç‚¹å’Œç»ˆç‚¹');
                return;
            }

            document.getElementById('loading-indicator').style.display = 'inline';
            
            // è·å–èˆªçº¿æ–‡ä»¶å
            const routeFileName = getRouteFileName(startPoint, endPoint);
            debugLog(`æ ¹æ®è¾“å…¥ç”Ÿæˆçš„æ–‡ä»¶å: ${routeFileName}`);
            
            // å°è¯•ä¸åŒæ ¼å¼çš„æ–‡ä»¶è·¯å¾„
            loadRouteFile(routeFileName);
        }

        // åŠ è½½èˆªçº¿æ–‡ä»¶
        function loadRouteFile(baseFileName) {
            // å°è¯•çš„æ–‡ä»¶è·¯å¾„æ•°ç»„ (æŒ‰ä¼˜å…ˆçº§æ’åº)
            const filePaths = [
                `routes/${baseFileName}.json`,
                `routes/${baseFileName}.txt`,
            ];
            
            debugLog(`å‡†å¤‡å°è¯•åŠ è½½æ–‡ä»¶è·¯å¾„: ${filePaths.join(', ')}`);
            
            // é€ä¸€å°è¯•åŠ è½½æ–‡ä»¶
            tryLoadFiles(filePaths, 0);
        }

        // é€’å½’å°è¯•åŠ è½½æ–‡ä»¶
        function tryLoadFiles(paths, index) {
            if (index >= paths.length) {
                // å·²å°è¯•æ‰€æœ‰è·¯å¾„ï¼Œä½†éƒ½å¤±è´¥äº†
                const error = `æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„èˆªçº¿æ–‡ä»¶`;
                console.error(error);
                alert(`åŠ è½½èˆªçº¿å¤±è´¥: ${error}\nè¯·æ£€æŸ¥:\n1. æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n2. æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®\n3. æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯`);
                document.getElementById('loading-indicator').style.display = 'none';
                return;
            }
            
            const currentPath = paths[index];
            debugLog(`å°è¯•åŠ è½½æ–‡ä»¶: ${currentPath}`);
            
            fetch(currentPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP é”™è¯¯! çŠ¶æ€: ${response.status}`);
                    }
                    
                    // æ ¹æ®æ–‡ä»¶æ‰©å±•åå¤„ç†ä¸åŒæ ¼å¼
                    if (currentPath.endsWith('.json')) {
                        return response.json().then(data => {
                            debugLog(`æˆåŠŸåŠ è½½ JSON æ–‡ä»¶: ${currentPath}`);
                            processJsonRoute(data);
                        });
                    } else if (currentPath.endsWith('.txt')) {
                        return response.text().then(data => {
                            debugLog(`æˆåŠŸåŠ è½½ TXT æ–‡ä»¶: ${currentPath}`);
                            processTxtRoute(data);
                        });
                    }
                })
                .then(() => {
                    document.getElementById('loading-indicator').style.display = 'none';
                })
                .catch(error => {
                    debugLog(`åŠ è½½æ–‡ä»¶å¤±è´¥: ${currentPath}, é”™è¯¯: ${error.message}`);
                    console.error(`å°è¯•åŠ è½½ ${currentPath} å¤±è´¥:`, error);
                    // å°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶
                    tryLoadFiles(paths, index + 1);
                });
        }

        // ç»˜åˆ¶èˆªçº¿
        function drawRoute() {
            // ç§»é™¤ä¹‹å‰çš„èˆªçº¿
            if (map.getLayer('route')) {
                map.removeLayer('route');
            }
            if (map.getSource('route')) {
                map.removeSource('route');
            }

            // å®‰å…¨æ£€æŸ¥
            if (!routeCoordinates || routeCoordinates.length < 2) {
                console.error('åæ ‡æ•°æ®ä¸è¶³');
                return;
            }

            // æ·»åŠ æ–°èˆªçº¿
            try {
                map.addSource('route', {
                    'type': 'geojson',
                    'data': {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': routeCoordinates
                        }
                    }
                });
                routeSource = 'route';

                map.addLayer({
                    'id': 'route',
                    'type': 'line',
                    'source': 'route',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': '#FF0000',
                        'line-width': 5
                    }
                });

                // æ·»åŠ èˆªç‚¹æ ‡è®°
                addWaypoints();

                // è°ƒæ•´åœ°å›¾è§†è§’
                const bounds = new mapboxgl.LngLatBounds();
                routeCoordinates.forEach(coord => bounds.extend(coord));
                
                map.fitBounds(bounds, {
                    padding: 50,
                    duration: 1000
                });
                
                debugLog("èˆªçº¿ç»˜åˆ¶æˆåŠŸ");
            } catch(e) {
                console.error('ç»˜åˆ¶èˆªçº¿æ—¶å‡ºé”™:', e);
                debugLog(`ç»˜åˆ¶èˆªçº¿å¤±è´¥: ${e.message}`);
                alert('ç»˜åˆ¶èˆªçº¿å¤±è´¥: ' + e.message);
            }
        }

        // æ·»åŠ èˆªç‚¹æ ‡è®°
        function addWaypoints() {
            // åªæ·»åŠ èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®°
            if (routeCoordinates.length >= 2) {
                // èµ·ç‚¹
                const startMarker = new mapboxgl.Marker({color: 'green'})
                    .setLngLat(routeCoordinates[0])
                    .setPopup(new mapboxgl.Popup().setHTML(`<h3>èµ·ç‚¹</h3><p>${routeMetadata.startPoint}</p>`))
                    .addTo(map);
                
                // ç»ˆç‚¹
                const endMarker = new mapboxgl.Marker({color: 'red'})
                    .setLngLat(routeCoordinates[routeCoordinates.length - 1])
                    .setPopup(new mapboxgl.Popup().setHTML(`<h3>ç»ˆç‚¹</h3><p>${routeMetadata.endPoint}</p>`))
                    .addTo(map);
                
                wayPointMarkers.push(startMarker, endMarker);
                debugLog("èˆªç‚¹æ ‡è®°æ·»åŠ æˆåŠŸ");
            }
        }

        // å¯åŠ¨èˆ¹åªåŠ¨ç”»
        function startShipAnimation() {
            // åˆ›å»ºæˆ–é‡ç½®èˆ¹åªæ ‡è®°
            if (shipMarker) {
                shipMarker.remove();
            }

            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }

            shipMarker = new mapboxgl.Marker({
                element: createShipElement(),
                anchor: 'center',
                rotationAlignment: 'map'
            })
            .setLngLat(routeCoordinates[0])
            .addTo(map);

            let currentIndex = 0;
            let lastTimestamp = 0;
            
            function animateShip(timestamp) {
                if (!lastTimestamp) lastTimestamp = timestamp;
                
                const elapsed = timestamp - lastTimestamp;
                
                if (elapsed > animationSpeed && currentIndex < routeCoordinates.length - 1) {
                    currentIndex++;
                    const nextCoord = routeCoordinates[currentIndex];
                    
                    // å¹³æ»‘ç§»åŠ¨
                    shipMarker.setLngLat(nextCoord);
                    
                    // è®¡ç®—èˆ¹çš„æ–¹å‘
                    if (currentIndex < routeCoordinates.length - 1) {
                        const nextPoint = routeCoordinates[currentIndex + 1];
                        const bearing = calculateBearing(nextCoord, nextPoint);
                        shipMarker.setRotation(bearing);
                    }
                    
                    lastTimestamp = timestamp;
                }
                
                if (currentIndex < routeCoordinates.length - 1) {
                    animationFrame = requestAnimationFrame(animateShip);
                } else {
                    // åŠ¨ç”»ç»“æŸ
                    debugLog('èˆªè¡Œå®Œæˆ');
                }
            }

            animationFrame = requestAnimationFrame(animateShip);
            
            // è·Ÿéšèˆ¹åªè§†è§’
            map.flyTo({
                center: routeCoordinates[0],
                zoom: 5,
                duration: 1000
            });
            
            debugLog("èˆ¹åªåŠ¨ç”»å·²å¯åŠ¨");
        }

        // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ–¹ä½è§’
        function calculateBearing(start, end) {
            const startLat = toRadians(start[1]);
            const startLng = toRadians(start[0]);
            const endLat = toRadians(end[1]);
            const endLng = toRadians(end[0]);
            
            const y = Math.sin(endLng - startLng) * Math.cos(endLat);
            const x = Math.cos(startLat) * Math.sin(endLat) - 
                    Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
            
            let bearing = Math.atan2(y, x);
            bearing = toDegrees(bearing);
            
            return (bearing + 360) % 360;
        }

        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function toDegrees(radians) {
            return radians * 180 / Math.PI;
        }

        // åˆ›å»ºèˆ¹åªå›¾æ ‡
        function createShipElement() {
            const el = document.createElement('div');
            el.innerHTML = 'ğŸš¢';
            el.style.fontSize = '30px';
            el.style.transform = 'translate(-50%, -50%)';  // ä¸­å¿ƒå¯¹é½
            return el;
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            console.error(message);
            alert(message);
        }

        // åœ°å›¾åŠ è½½å®Œæˆåçš„è®¾ç½®
        map.on('style.load', () => {
            map.setFog({
                'range': [0.8, 8],
                'color': 'white',
                'horizon-blend': 0.1
            });
            
            map.setLight({
                'anchor': 'viewport',
                'color': 'white',
                'intensity': 0.4
            });

            map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
            
            debugLog("åœ°å›¾åŠ è½½å®Œæˆ");
        });
    </script>
</body>
</html>
